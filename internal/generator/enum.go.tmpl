// Code generated by enum generator; DO NOT EDIT.
package {{.Package}}

import (
	"fmt"

	{{- if .GenerateSQL }}
	"database/sql/driver"
	{{- end}}
	{{- if .GenerateBSON }}
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/bsontype"
	{{- end}}
	{{- if .GenerateYAML }}
	"gopkg.in/yaml.v3"
	{{- end}}
	"strings"
)

// {{.Type | title}} is the exported type for the enum
type {{.Type | title}} struct {
	name  string
	value {{if .UnderlyingType}}{{.UnderlyingType}}{{else}}int{{end}}
}

func (e {{.Type | title}}) String() string { return e.name }

// Index returns the underlying integer value
func (e {{.Type | title}}) Index() {{if .UnderlyingType}}{{.UnderlyingType}}{{else}}int{{end}} { return e.value }

// MarshalText implements encoding.TextMarshaler
func (e {{.Type | title}}) MarshalText() ([]byte, error) {
	return []byte(e.name), nil
}

// UnmarshalText implements encoding.TextUnmarshaler
func (e *{{.Type | title}}) UnmarshalText(text []byte) error {
	var err error
	*e, err = Parse{{.Type | title}}(string(text))
	return err
}

{{- if .GenerateSQL }}
// Value implements the driver.Valuer interface
func (e {{.Type | title}}) Value() (driver.Value, error) {
	return e.name, nil
}

// Scan implements the sql.Scanner interface
func (e *{{.Type | title}}) Scan(value interface{}) error {
	if value == nil {
		// try to find zero value
		for _, v := range {{.Type | title}}Values {
			if v.Index() == 0 {
				*e = v
				return nil
			}
		}
		// no zero value found, return error
		return fmt.Errorf("cannot scan nil into {{.Type | title}}: no zero value defined")
	}

	str, ok := value.(string)
	if !ok {
		if b, ok := value.([]byte); ok {
			str = string(b)
		} else {
			return fmt.Errorf("invalid {{.Type}} value: %v", value)
		}
	}

	val, err := Parse{{.Type | title}}(str)
	if err != nil {
		return err
	}

	*e = val
	return nil
}
{{- end }}

{{- if .GenerateBSON }}
// MarshalBSONValue implements bson.ValueMarshaler and encodes the enum as a string
func (e {{.Type | title}}) MarshalBSONValue() (bsontype.Type, []byte, error) {
	return bson.MarshalValue(e.String())
}

// UnmarshalBSONValue implements bson.ValueUnmarshaler and decodes the enum from a string
func (e *{{.Type | title}}) UnmarshalBSONValue(t bsontype.Type, data []byte) error {
	var s string
	if err := bson.UnmarshalValue(t, data, &s); err != nil {
		return err
	}
	val, err := Parse{{.Type | title}}(s)
	if err != nil {
		return err
	}
	*e = val
	return nil
}
{{- end }}

{{- if .GenerateYAML }}
// MarshalYAML implements yaml.Marshaler and encodes the enum as a string
func (e {{.Type | title}}) MarshalYAML() (any, error) {
	return e.String(), nil
}

// UnmarshalYAML implements yaml.Unmarshaler and decodes the enum from a string scalar
func (e *{{.Type | title}}) UnmarshalYAML(value *yaml.Node) error {
	if value == nil || value.Kind != yaml.ScalarNode {
		return fmt.Errorf("invalid YAML for {{.Type}}: expected scalar string")
	}
	val, err := Parse{{.Type | title}}(value.Value)
	if err != nil {
		return err
	}
	*e = val
	return nil
}
{{- end }}

// _{{.Type}}ParseMap is used for efficient string to enum conversion
var _{{.Type}}ParseMap = map[string]{{.Type | title}}{
{{range $v := .Values -}}
	"{{$v.Name | ToLower}}": {{$v.PublicName}},
{{- range $alias := $v.Aliases}}
{{- if ne ($alias | ToLower) ($v.Name | ToLower)}}
	"{{$alias | ToLower}}": {{$v.PublicName}},
{{- end}}
{{- end}}
{{end}}
}

// Parse{{.Type | title}} converts string to {{.Type}} enum value.
// Parsing is always case-insensitive.
func Parse{{.Type | title}}(v string) ({{.Type | title}}, error) {
	if val, ok := _{{.Type}}ParseMap[strings.ToLower(v)]; ok {
		return val, nil
	}
	return {{.Type | title}}{}, fmt.Errorf("invalid {{.Type}}: %s", v)
}

// Must{{.Type | title}} is like Parse{{.Type | title}} but panics if string is invalid
func Must{{.Type | title}}(v string) {{.Type | title}} {
	r, err := Parse{{.Type | title}}(v)
	if err != nil {
		panic(err)
	}
	return r
}

{{if .GenerateGetter -}}
// Get{{.Type | title}}ByID gets the correspondent {{.Type}} enum value by its ID (raw integer value)
func Get{{.Type | title}}ByID(v {{if .UnderlyingType}}{{.UnderlyingType}}{{else}}int{{end}}) ({{.Type | title}}, error) {
	switch v {
	{{range .Values -}}
	case {{.Index}}:
		return {{.PublicName}}, nil
	{{end -}}
	}
	return {{.Type | title}}{}, fmt.Errorf("invalid {{.Type}} value: %d", v)
}
{{end -}}

// Public constants for {{.Type}} values
var (
{{range .Values -}}
	{{.PublicName}} = {{$.Type | title}}{name: "{{if $.LowerCase}}{{.Name | ToLower}}{{else}}{{.Name}}{{end}}", value: {{.Index}}}
{{end -}}
)

// {{.Type | title}}Values contains all possible enum values
var {{.Type | title}}Values = []{{.Type | title}}{
{{range .Values -}}
	{{.PublicName}},
{{end -}}
}

// {{.Type | title}}Names contains all possible enum names
var {{.Type | title}}Names = []string{
{{range .Values -}}
	"{{if $.LowerCase}}{{.Name | ToLower}}{{else}}{{.Name}}{{end}}",
{{end -}}
}

// {{.Type | title}}Iter returns a function compatible with Go 1.23's range-over-func syntax.
// It yields all {{.Type | title}} values in declaration order. Example:
//
//	for v := range {{.Type | title}}Iter() {
//	    // use v
//	}
//
func {{.Type | title}}Iter() func(yield func({{.Type | title}}) bool) {
	return func(yield func({{.Type | title}}) bool) {
		for _, v := range {{.Type | title}}Values {
			if !yield(v) {
				break
			}
		}
	}
}

// These variables are used to prevent the compiler from reporting unused errors
// for the original enum constants. They are intentionally placed in a var block
// that is compiled away by the Go compiler.
var _ = func() bool {
    var _ {{.Type}} = {{if .UnderlyingType}}{{.Type}}(0){{else}}0{{end}}
    {{range .Values -}}
    // This avoids "defined but not used" linter error for {{.PrivateName}}
    var _ {{$.Type}} = {{.PrivateName}}
    {{end -}}
    return true
}()
